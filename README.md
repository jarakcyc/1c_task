# Задача A001

## Формализуем условие
Итак, формальное условие задачи:
Есть 3 типа запросов:
1) Добавить n строк в набор
2) Ввести строку и выдать строку из набора с таким префиксом, которая встерчалась чаще других
3) Дописать символы к предыдущему запросу

## Идеи решения
### 1 идея
Будем строить бор на словах из набора и в терминальных вершинах будем сохранять количество таких слов.
При запросе 2ого типа будем спускаться по бору и тогда, чтобы ответить на запрос необходимо будет найти терминальную
вершину в поддереве вершины, в которую пришли, с максимальным значением count. При дописывании символов будем продвигаться
дальше по бору.

Оценка сложности: Бор строится за суммарную длину всех строк в наборе (O(S)). Поиск терминальной вершины можно делать 
полным проходом по поддереву текущей вершины. Тогда опять же в худшем случае(при пустом запросе) сложность будет O(S).

#### Оптимизации
1) Для у меньшения размера бора, можно использовать сжатый бор(на ребрах писать не символы, а строки).
2) Можно в каждой ноде хранить строку в ее поддереве, котрая чаще всех встречается(фактически ответ на запрос 2ого типа).
Тогда если сделать добавление новой строки рекурсивным, то можно по ходу обновлять это поле. В такой реализации все добавления будут
выполнены за O(S * k), где k - число все возможных символом. Ответ на запрос будет выполняться за O(1).

#### Реализация
Запросы будут выглядеть следующим образом:
1) ! n str_1 str_2 ... str_n
2) ? pref
3) + str

Весь исходный код находится в файле src.cpp