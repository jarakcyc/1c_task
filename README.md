# Задача A001

## Формализуем условие
Итак, формальное условие задачи:
Есть 3 типа запросов:
1) Добавить n строк в набор
2) Ввести строку и выдать строку из набора с таким префиксом, которая встерчалась чаще других
3) Дописать символы к предыдущему запросу

## Идеи решения
### 1 идея
Будем строить бор на словах из набора и в терминальных вершинах будем сохранять количество таких слов.
При запросе 2ого типа будем спускаться по бору и тогда, чтобы ответить на запрос необходимо будет найти терминальную
вершину в поддереве вершины, в которую пришли, с максимальным значением counter. При дописывании символов будем продвигаться
дальше по бору.

Оценка сложности: Бор строится за суммарную длину всех строк в наборе (O(S)). Поиск терминальной вершины можно делать 
полным проходом по поддереву текущей вершины. Тогда опять же в худшем случае(при пустом запросе) сложность будет O(S).

#### Оптимизации
1) Для уменьшения размера бора, можно использовать сжатый бор(на ребрах писать не символы, а строки).
2) Можно в каждой ноде хранить строку в ее поддереве, которая чаще всех встречается(фактически ответ на запрос 2ого типа).
Тогда если сделать добавление новой строки рекурсивным, то можно по ходу обновлять это поле. В такой реализации все добавления будут
выполнены так же за O(S). Ответ на запрос будет выполняться за O(1). Но в данной оптимизации получается проигрыш по памяти за счет того, что 
в каждой ноде приходится хранить целую строку, O(S^2).


#### Замечание
Второй подход лучше, только если суммарная длина добавленных строк S не очень большая, так как сохранение лучшей строки в ноде
порождает дополнительные расходы по памяти и в итоге требует O(S^2) памяти.

#### Реализация
Запросы будут выглядеть следующим образом:
1) !(воскл знак) n str_1 str_2 ... str_n
2) ?(знак вопроса) pref
3) +(плюс) str

Исходный код реализации начальной идеи находится в файле first_solution.cpp
Исходный код реализации с рекурсивным add и сохранением лучшего слова в node в second_solution.cpp